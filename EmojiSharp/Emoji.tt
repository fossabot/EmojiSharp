<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\packages\Newtonsoft.Json.7.0.1\lib\net45\Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ template hostspecific="true" language="C#" #>
<#
	//Options & Settings

	//Whether to generate the static properties referencing each Emoji
    bool GenerateStaticProperties = true;

	//Name filter for emojis - set this to only only generate classes
	//for emoji that contain key words (clean name format, all underscores)
	//Example: string[] NameFilter = {"FACE"};
    string[] NameFilter = {};

	//Category filter for emojis - set this to only only generate
	//emojis in the given categories. See EmojiCategory enum below for examples
	//Example: string[] CategoryFilter = {"People"};
    string[] CategoryFilter = {};

#>
/*
	EmojiSharp v0.2
	Created by John Mazouri - http://jmazouri.com/
	emoji.json from the awesome emoji-data project - https://github.com/iamcal/emoji-data

	This file should have been autogenerated from a T4 template - feel free to delete the
	template if you're never going to need to update the emoji list later on.
*/

using System;   
using System.Collections.Generic;

namespace EmojiSharp
{
	public enum EmojiCategory
	{
		Symbols,
		Nature,
		Foods,
		People,
		Places,
		Activity,
		Celebration,
		Other
	}

	public partial class Emoji
	{
		public string Name { get; set; }
        public string Unified { get; set; }
        public string[] Variations { get; set; }
        public string Docomo { get; set; }
        public string Au { get; set; }
        public string Softbank { get; set; }
        public string Google { get; set; }
        public string Image { get; set; }
        public int SheetX { get; set; }
        public int SheetY { get; set; }
        public string ShortName { get { return ShortNames != null && ShortNames.Length > 0 ? ShortNames[0] : null; }}
        public string[] ShortNames { get; set; }
        public string Text { get { return Texts != null && Texts.Length > 0 ? Texts[0] : null; }}
        public string[] Texts { get; set; }
        public EmojiCategory Category { get; set; }
        public int SortOrder { get; set; }
        public bool AppleHasImage { get; set; }
        public bool GoogleHasImage { get; set; }
        public bool TwitterHasImage { get; set; }
        public bool EmojioneHasImage { get; set; }

		public override string ToString()
		{
			return ShortName;
		}

		public string AsShortcode()
		{
			return String.Format(":{0}:", ShortName);
		}

		public static Dictionary<string, Emoji> All = new Dictionary<string, Emoji>()
		{
	<#
		var emojis = JArray.Parse(File.ReadAllText(Host.ResolvePath("emoji.json")));

		foreach (var entry in emojis)
		{
		    string cleanedName = entry["name"].Value<string>().Replace(' ', '_').Replace('-', '_').Trim();
			if (String.IsNullOrWhiteSpace(cleanedName)) continue;

		    if (NameFilter.Length > 0 && !NameFilter.Any(d=>cleanedName.Contains(d))) continue;

		    string cleanedCategory = entry["category"].Value<string>() ?? "Other";

		    if (CategoryFilter.Length > 0 && !CategoryFilter.Contains(cleanedCategory)) continue;
		    
	#>
		{"<#=entry["short_names"].First().Value<string>()#>", 
			new Emoji 
			{
				Name = <#=QuotedValue(entry["name"])#>,
				Category = EmojiCategory.<#=cleanedCategory#>,
				SortOrder = <#=(entry["sort_order"].Value<string>() ?? "0")#>,

				Unified = <#=QuotedValue(entry["unified"])#>,
				Variations = <#=TokenToCsharpArray(entry["variations"])#>,

				Docomo = <#=QuotedValue(entry["docomo"])#>,
				Au = <#=QuotedValue(entry["au"])#>,
				Softbank = <#=QuotedValue(entry["softbank"])#>,
				Google = <#=QuotedValue(entry["google"])#>,

				AppleHasImage = <#=entry["has_img_apple"].Value<string>().ToLower()#>,
				GoogleHasImage = <#=entry["has_img_google"].Value<string>().ToLower()#>,
				TwitterHasImage = <#=entry["has_img_twitter"].Value<string>().ToLower()#>,
				EmojioneHasImage = <#=entry["has_img_emojione"].Value<string>().ToLower()#>,

				Image = <#=QuotedValue(entry["image"])#>,
				SheetX = <#=(entry["sheet_x"].Value<string>()?? "0")#>,
				SheetY = <#=(entry["sheet_y"].Value<string>()?? "0")#>,

				ShortNames = <#=TokenToCsharpArray(entry["short_names"])#>,
				Texts = <#=TokenToCsharpArray(entry["texts"])#>
			}},

	<#
		}
	#>
	};

	<# 
		if (GenerateStaticProperties)
		{
			foreach (var entry in emojis)
			{
				string cleanedName = entry["name"].Value<string>().Replace(' ', '_').Replace('-', '_').Trim();
				if (String.IsNullOrWhiteSpace(cleanedName)) { continue; }
    #>
	public static Emoji <#=cleanedName#> { get { return All["<#=entry["short_names"].First().Value<string>()#>"]; } }
	<#
			}
		}
	#>
	}
}

<#+
    public string TokenToCsharpArray(JToken token, bool includeCtor = true)
    {
        string result = 
			token.HasValues
            ? token.Select(d => '"' + d.Value<string>() + '"').Aggregate((cur, next) => cur + ", " + next)
            : string.Empty;

        if (includeCtor)
        {
			return "new string[] { " + result + " }";
        }

        return result;
    }

    public string QuotedValue(object input)
    {
        if (String.IsNullOrEmpty(input.ToString())) return "null";
		return String.Format("\"{0}\"", input);
    }
#>